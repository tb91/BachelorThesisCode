package projects.reactiveSpanner.routing;

import java.util.Set;

import projects.reactiveSpanner.Algorithms;
import projects.reactiveSpanner.nodes.messageHandlers.SubgraphStrategy.EStrategy;
import projects.reactiveSpanner.nodes.nodeImplementations.PhysicalGraphNode;

/**
 * Simple greedy routing algorithm. Getting the neighbor node of the requested SubgraphStrategy as long
 * 
 * @author Matthias von Steimker
 * @param <T>
 */
public class GreedyRouting<T extends PhysicalGraphNode> extends RoutingProtocol<T>
{
	private boolean stucking;
	
	protected GreedyRouting(final T sourceNode, final T destinationNode, final T currentHolder, final EStrategy subgraphStrategy) {
		super(sourceNode, destinationNode, currentHolder, subgraphStrategy);	
	}
	
	@Override
	protected void init() {
		stucking = false;
	}

	@Override
	protected void _requestedNextRoutingStep()
	{	
		nextHop = calculateNextHop();
	}
	
	/**
	 * @return
	 */
	private T calculateNextHop()
	{
		Set<T> subgraphNodes = subgraphInterface.getSubgraphNodes();
		
		//TODO taking only nodes in UDG distance to the holding node, make also other connectivity models available
		subgraphNodes = Algorithms.getOneHopNeighbors(currentHolder, subgraphNodes);
		
		T mostGainedNode = this.currentHolder;
		for(T neighbor: subgraphNodes)
		{
			if(neighbor.getPosition().squareDistanceTo(super.getDestination().getPosition()) <
					mostGainedNode.getPosition().squareDistanceTo(super.getDestination().getPosition()))
			{
				mostGainedNode = neighbor;
			}
		}
		if(mostGainedNode.equals(this.currentHolder))
		{
			this.stucking = true;
			return null;
		}
		else
		{
			this.stucking = false;
			return mostGainedNode;
		}
	}

	@Override
	protected boolean _isStucked() {
		return stucking;
	}
}
