package projects.reactiveSpanner.nodes.messageHandlers.BCA;

import java.awt.Color;
import java.awt.Graphics;
import java.util.UUID;

import projects.reactiveSpanner.nodes.timers.BCA.PauseTimer;
import projects.reactiveSpanner.nodes.messages.BCA.FirstRequest;
import projects.reactiveSpanner.nodes.messages.BCA.FirstResponse;
import projects.reactiveSpanner.nodes.messages.BCA.SecondRequest;
import projects.reactiveSpanner.nodes.messages.BCA.SecondResponse;
import projects.reactiveSpanner.nodes.messageHandlers.AbstractMessageHandler;
import projects.reactiveSpanner.nodes.messageHandlers.BeaconlessTopologyControl;
import projects.reactiveSpanner.nodes.messages.AbstractMessage;
import projects.reactiveSpanner.nodes.nodeImplementations.PhysicalGraphNode;
import projects.reactiveSpanner.nodes.timers.BCA.BCAMessageTimer;
import projects.reactiveSpanner.nodes.timers.BCA.FirstRequestPhaseDoneTimer;
import projects.reactiveSpanner.record.MessageRecord;
import sinalgo.configuration.Configuration;
import sinalgo.configuration.CorruptConfigurationEntryException;
import sinalgo.gui.transformation.PositionTransformation;
import sinalgo.models.ConnectivityModel;
import sinalgo.nodes.Position;
import sinalgo.runtime.Global;
import sinalgo.tools.Tools;
import sinalgo.tools.logging.LogL;

public class BCAMessageHandler extends AbstractMessageHandler<PhysicalGraphNode> {

	public BCAMessageTimer firstRequestTimer;
	public BCAMessageTimer firstResponseTimer;
	public FirstRequestPhaseDoneTimer firstRequestPhaseDoneTimer;
	public PauseTimer pauseTimer;
	
	private boolean checkedConnectionModel = false;
	
	public double tmaxTime = -1;
	
	public Position[] activeCells;
	
	protected static double tmax;{
		try {
			tmax = Configuration.getIntegerParameter("Timer/BCAtMax");
		} catch(CorruptConfigurationEntryException e) {
			Tools.fatalError(e.getMessage());
		}
	}
	
	protected static int udr;{
		try {
			udr = Configuration.getIntegerParameter("UDG/rMax");
		} catch(CorruptConfigurationEntryException e) {
			Tools.fatalError(e.getMessage());
		}
	}
	
	protected int rMin;{
		try {
			rMin = Configuration.getIntegerParameter("QUDG/rMin");
		} catch(CorruptConfigurationEntryException e) {
			Tools.fatalError(e.getMessage());
		}
	}
	
	protected int rMax;{ 
		try {
			rMax = Configuration.getIntegerParameter("QUDG/rMax");
		} catch(CorruptConfigurationEntryException e) {
			Tools.fatalError(e.getMessage());
		}
	}
	
	protected double kacheldiagonale = rMin;
	protected double kachelbreite = Math.sqrt((rMin * rMin) / 2);
	
	public BCAMessageHandler(final UUID tcID, final PhysicalGraphNode ownerNode,
			final PhysicalGraphNode sourceNode) {
		super(tcID, ownerNode, sourceNode, BeaconlessTopologyControl.EStrategy.BCA);
	}

	@Override
	public void receivedMessage(AbstractMessage msg) {

		if (msg instanceof FirstRequest) {
			receivedFirstRequest((FirstRequest) msg);
		}
		
		if (msg instanceof FirstResponse) {
			receivedFirstResponse((FirstResponse) msg);
		}
		
		if (msg instanceof SecondRequest) {
			receivedSecondRequest((SecondRequest) msg);
		}
		
		if (msg instanceof SecondResponse) {
			receivedSecondResponse((SecondResponse) msg);
		}
	}
	
	public void receivedFirstRequest(FirstRequest msg) {
		
		if (!checkedConnectionModel) {
			String cm = this.node.getConnectivityModel().getClass().getName();
			String UDG = ConnectivityModel.getConnectivityModelInstance("UDG").getClass()
					.getName();
//			String QUDG = ConnectivityModel.getConnectivityModelInstance("StaticQUDG")
//					.getClass().getName();

			if (cm.equals(UDG)) {
				rMin = udr;
				rMax = rMin;
			}
			
			checkedConnectionModel = true;
		}
		
		// Falls ein Timer für FirstRequest schon läuft, wird er um tmax verlängert
		if (activeCells != null && firstRequestTimer != null
				&& firstRequestTimer.getFireTime() >= Global.currentTime) {
			
			double pause = firstRequestTimer.getFireTime()
					- Tools.getGlobalTime();
			firstRequestTimer.disable();
			firstRequestTimer = null;
			pauseTimer = new PauseTimer(pause, this);
			pauseTimer.startRelative(tmax + 4, this.node);
			
			logger.logln(LogL.INFO, this.node.toString() + " pause for " + (tmax + 4) + "+" + pause + " rounds.");
		} else {
			if (getKachel(this.node).equals(getKachel(msg.getSource()))) {
				// gleiche Kachel: Verfahren beenden (tue nichts)
			} else {
				// eigene Kachel addressiert? > Timer für FirstResponse setzen
				if (isMessageForMe(msg.getDirectCells())) {
					// euklidische Distanz d berechnen: |Knoten <-> MittelPunkt Kachel|
					double d = this.getKachelMitte().distanceTo(
							this.node.getPosition());
					// Timerwert t berechnen
					double t = ((d) / (0.5 * kacheldiagonale)) * tmax;
					sendFirstResponse(t);
					logger.logln(LogL.INFO, this.node.toString() + " start FirstResponseTimer with t = " + t);
				}
			}
		}
	}
	
	public void receivedFirstResponse(FirstResponse msg) {
		
		// firstResponseTimer not finished yet?
		if (firstResponseTimer != null  && firstResponseTimer.getFireTime() > Global.currentTime) {
			// falls FirstResponse aus der eigenen Kachel kam > Timer abbrechen
			if (getKachel(this.node).equals(getKachel(msg.getSource()))) {
				firstResponseTimer.disable();
				this.node.setColor(Color.BLACK);
				logger.logln(LogL.INFO, "	" + this.node.toString() + " cancels timer");
			}
		} else {
			//firstResponseTimer wurde bereits gefeuert
			//Antwort eines Knotens aus aktiver Kachel an Forwarder weiterleiten
			if (activeCells != null && firstRequestTimer != null
					&& firstRequestTimer.getFireTime() < Tools.getGlobalTime()
					&& isInAktiveKacheln(getKachel(msg.getSource()))) {

				broadcastSecondResponse(1, msg.getSource());
				this.knownNeighbors.add(msg.getSource());

				for (int i = 0; i < activeCells.length; i++) {
					if (activeCells[i] != null
							&& activeCells[i]
									.equals(getKachel(msg.getSource()))) {
						activeCells[i] = null;
					}
				}
				
				if (isAktiveKachelnLeer()) {
					activeCells = null;
					firstRequestTimer.disable();
					firstRequestTimer = null;
				}

			} else {
				//die Nachricht kommt von einem Knoten aus einer aktiven Kachel,
				//für die wir noch keine Anfrage geschickt haben > Knoten aus aktiven Kacheln löschen
				
				if (activeCells != null && pauseTimer != null) {
					for (int i = 0; i < activeCells.length; i++) {
						if (activeCells[i] != null
								&& activeCells[i].equals(getKachel(msg
										.getSource()))) {
							activeCells[i] = null;
						}
					}
					logger.logln(LogL.INFO, "	" + this.node.toString() + " deletes some active cells");
					
					if (isAktiveKachelnLeer()) {
						activeCells = null;
						firstRequestTimer.disable();
						firstRequestTimer = null;
					}
				}
			}
		}
	}
	
	public void receivedSecondRequest(SecondRequest msg) {
		
		if (getKachel(this.node).equals(getKachel(msg.getSource()))) {
			
			pauseTimer = null;
			
			activeCells = msg.getIndirectCells().clone();
			
//			System.out.println("          KONTROLLE          ");
//			String tempStr = "";
//			for (Position p : activeCells) {
//				if (p == null) continue;
//				tempStr += "[" + p.xCoord + " | " + p.yCoord + " | " + p.zCoord + "]" + "   ";
//			}
//			System.out.println("          " + this.node.toString() + " ; " + tempStr);
			
			double[] t = new double[activeCells.length];
			
			// Jetzt muss die Entfernung zur jeweiligen Kachel berechnet
			// werden, womit der Timer bestimmt werden kann (d*tmax)
			for (int i = 0; i < activeCells.length; i++) {
				t[i] = isKachelInRadius(activeCells[i]);
			}
			
			double tmin = tmax + 1;
			
			for (int i = 0; i < t.length; i++) {
				if (t[i] > 0 && t[i] < tmin)
					tmin = t[i];
			}
			
			if (tmin < tmax + 1 & tmin != 0) {
				broadcastFirstRequest(tmin);
				logger.logln(LogL.INFO, this.node.toString() + " start FirstRequestTimer with t = " + tmin);
				this.node.setColor(Color.CYAN);
			}
		}
	}
	
	public void receivedSecondResponse(SecondResponse msg) {

		try {
			if (pauseTimer != null && isInAktiveKacheln(getKachel(msg.getSource()))) {
			
				// Kachel merken

				for (int i = 0; i < activeCells.length; i++) {
					if (activeCells[i] != null
							&& activeCells[i]
									.equals(getKachel(msg.getSource()))) {
						activeCells[i] = null;
					}
				}

				// Offene Kacheln übrig?
				boolean empty = true;
				// Gibt es noch offene Kacheln?
				if (activeCells != null) {
					for (int i = 0; i < activeCells.length; i++) {
						if (activeCells[i] != null)
							empty = false;
					}
				}
				
				boolean inReach = false;
				//Sind offene Kacheln erreichbar?
				if (activeCells != null){
					for (Position p : activeCells){
						if (isKachelInRadius(p) !=0) inReach = true;
					}
				}
				

				if (empty || !inReach) {
					// nein > Timer beenden
					activeCells = null;
					pauseTimer.disable(); // zur Sicherheit
					pauseTimer = null;
					logger.logln(LogL.INFO, "	" + this.node.toString()
							+ " cancels FirstRequestTimer.");
					logger.logln(LogL.INFO, "	" + this.node.toString()
							+ " has no active nor reachable cells anymore.");

					this.node.setColor(Color.BLACK);

				} else {
					// ja > nichts tun
				}

			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public void broadcastFirstRequest(double timer) {
		firstRequestTimer = new BCAMessageTimer(new FirstRequest(this.tcID,
				this.node, activeCells));
		firstRequestTimer.startRelative(timer, node);
		
		if (firstRequestPhaseDoneTimer != null) {firstRequestPhaseDoneTimer.disable();}
		firstRequestPhaseDoneTimer = new FirstRequestPhaseDoneTimer(this);
		firstRequestPhaseDoneTimer.startRelative(firstRequestTimer.getFireTime() + tmax + 5, this.node);
	}
	
	public void sendFirstResponse(double timer){
		if (firstResponseTimer != null) {
			firstResponseTimer.disable();
		}
		firstResponseTimer = new BCAMessageTimer(new FirstResponse(
				this.tcID, this.node));
		firstResponseTimer.startRelative(timer, this.node);
	}

	public void broadcastSecondResponse(double timer, PhysicalGraphNode sourceNode){
		BCAMessageTimer secondResponseTimer = new BCAMessageTimer(new SecondResponse(this.tcID, this.node, sourceNode));
		secondResponseTimer.startRelative(timer, this.node);
	}
	
	public void firstRequestPhaseDone() {
		if (firstRequestTimer != null) {
			firstRequestTimer.disable();
			firstRequestTimer = null;

			logger.logln("Round " + Global.currentTime + ": "
					+ this.node.ID
					+ ": beendet Wartezeit auf Antwort von erreichbaren Knoten.");
			
			if (!this.node.getColor().equals(Color.RED))
				this.node.setColor(Color.BLACK);
		}
	}

	@Override
	public void drawNode(Graphics g, PositionTransformation pt) {
	}

	@Override
	public MessageRecord getCurrentMessageRecord() {
		// Auto-generated method stub
		return null;
	}
	
	
//-------------------------------------------------------------------------
//	Kachel-Funktionen
//-------------------------------------------------------------------------	
	
	public Position[] getDirectCells() {

		Position[] directCells = new Position[24];
		for (int i = 0; i < 24; i++) {
			if (i < 12)
				directCells[i] = getKachelX(i);
			if (i >= 12)
				directCells[i] = getKachelX(i + 1);
		}

		return directCells;
	}

	/**
	 * Gibt zur ID einer Kachel die fortlaufenden Nummerierung zurück. Für
	 * Kachel 0 gibt die Methode (1,0,0) zurück.
	 */
	public Position getKachelX(int i) {
		Position myKachel = this.getKachel(this.node);
		double x = myKachel.xCoord;
		double y = myKachel.yCoord;
		Position[] tmp = new Position[25];
		tmp[0] = new Position(x - 2, y - 2, 0);
		tmp[1] = new Position(x - 1, y - 2, 0);
		tmp[2] = new Position(x + 0, y - 2, 0);
		tmp[3] = new Position(x + 1, y - 2, 0);
		tmp[4] = new Position(x + 2, y - 2, 0);
		tmp[5] = new Position(x - 2, y - 1, 0);
		tmp[6] = new Position(x - 1, y - 1, 0);
		tmp[7] = new Position(x + 0, y - 1, 0);
		tmp[8] = new Position(x + 1, y - 1, 0);
		tmp[9] = new Position(x + 2, y - 1, 0);
		tmp[10] = new Position(x - 2, y + 0, 0);
		tmp[11] = new Position(x - 1, y + 0, 0);
		tmp[12] = new Position(x + 0, y + 0, 0);
		tmp[13] = new Position(x + 1, y + 0, 0);
		tmp[14] = new Position(x + 2, y + 0, 0);
		tmp[15] = new Position(x - 2, y + 1, 0);
		tmp[16] = new Position(x - 1, y + 1, 0);
		tmp[17] = new Position(x - 0, y + 1, 0);
		tmp[18] = new Position(x + 1, y + 1, 0);
		tmp[19] = new Position(x + 2, y + 1, 0);
		tmp[20] = new Position(x - 2, y + 2, 0);
		tmp[21] = new Position(x - 1, y + 2, 0);
		tmp[22] = new Position(x + 0, y + 2, 0);
		tmp[23] = new Position(x + 1, y + 2, 0);
		tmp[24] = new Position(x + 2, y + 2, 0);
		return tmp[i];
	}

	/**
	 * Gibt an, in welcher Kachel der Knoten liegt. Dabei werden nicht die
	 * Koordinaten des Kachelursprungs zurückgegeben, sondern die fortlaufende
	 * Bezeichnung. Die zweite Kachel von oben links würde beispielsweise
	 * (1,0,0) zurückgeben.
	 */
	public Position getKachel(PhysicalGraphNode node) {
		double x = getKachelPosition(node).xCoord;
		double y = getKachelPosition(node).yCoord;
		double cx = x / kachelbreite;
		double cy = y / kachelbreite;
		return new Position(cx, cy, 0);
	}

	/**
	 * Gibt die Koordinaten der linke oberen Ecke der Kachel, in der der Knoten
	 * liegt, zurück.
	 */
	public Position getKachelPosition(PhysicalGraphNode node) {
		double x = node.getPosition().xCoord;
		double y = node.getPosition().yCoord;
		double cx = x - x % kachelbreite;
		double cy = y - y % kachelbreite;
		return new Position(cx, cy, 0);
	}
	
	/**
	 * @param msg
	 *            Nachricht vom Typ FirstRequest
	 * @return true, wenn das Array "msg.getDestKachel[]" den Eintrag
	 *         this.getKachel() enthält.
	 */
	public boolean isMessageForMe(Position[] cells) {
		Position[] array = cells;
		for (int i = 0; i < array.length; i++) {
			if (array[i] != null && array[i].equals(getKachel(this.node)))
				return true;
		}
		return false;
	}
	
	/**
	 * Gibt die Koordinaten des Mittelpunkts der Kachel, in der der Knoten
	 * liegt, zurÃ¼ck.
	 */
	public Position getKachelMitte() {
		Position kachelMitte = getKachelPosition(this.node);
		kachelMitte.xCoord = kachelMitte.xCoord
				+ (kacheldiagonale / Math.sqrt(8));
		kachelMitte.yCoord = kachelMitte.yCoord
				+ (kacheldiagonale / Math.sqrt(8));
		return kachelMitte;
	}

	public Position kachelToKachelMitte(Position p) {
		double x = p.xCoord * kachelbreite;
		double y = p.yCoord * kachelbreite;
		x = x + 0.5 * kachelbreite;
		y = y + 0.5 * kachelbreite;
		return new Position(x, y, 0);
	}

	public Position kachelToKachelEckeObenRechts(Position p) {
		double x = p.xCoord * kachelbreite;
		double y = p.yCoord * kachelbreite;
		x = x + kachelbreite;
		return new Position(x, y, 0);
	}

	public Position kachelToKachelEckeUntenRechts(Position p) {
		double x = p.xCoord * kachelbreite;
		double y = p.yCoord * kachelbreite;
		x = x + kachelbreite;
		y = y + kachelbreite;
		return new Position(x, y, 0);
	}

	public Position kachelToKachelEckeUntenLinks(Position p) {
		double x = p.xCoord * kachelbreite;
		double y = p.yCoord * kachelbreite;
		y = y + kachelbreite;
		return new Position(x, y, 0);
	}

	public Position kachelToKachelEckeObenLinks(Position p) {
		double x = p.xCoord * kachelbreite;
		double y = p.yCoord * kachelbreite;
		return new Position(x, y, 0);
	}

	public Position kachelToKachelMitteUnten(Position p) {
		double x = p.xCoord * kachelbreite + 0.5 * kachelbreite;
		double y = p.yCoord * kachelbreite + 1.0 * kachelbreite;
		return new Position(x, y, 0);
	}

	public Position kachelToKachelMitteOben(Position p) {
		double x = p.xCoord * kachelbreite + 0.5 * kachelbreite;
		double y = p.yCoord * kachelbreite;
		return new Position(x, y, 0);
	}

	public Position kachelToKachelMitteLinks(Position p) {
		double x = p.xCoord * kachelbreite;
		double y = p.yCoord * kachelbreite + 0.5 * kachelbreite;
		return new Position(x, y, 0);
	}

	public Position kachelToKachelMitteRechts(Position p) {
		double x = p.xCoord * kachelbreite + 1.0 * kachelbreite;
		double y = p.yCoord * kachelbreite + 0.5 * kachelbreite;
		return new Position(x, y, 0);
	}

	
	/**
	 * @return double 0<t<=tmax, wenn die Kachel im Senderadius liegt, oder t=0,
	 *         wenn die Kachel nicht im Senderadius liegt.
	 */
	public double isKachelInRadius(Position kachel) {
		double t = 0;
		if (kachel == null)
			return 0;
		if (kachel.equals(getKachelX(0))) {
			// untere rechte Ecke der Kachel0 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeUntenRechts(getKachelX(0));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kacheldiagonale) / (rMax - kacheldiagonale)) * tmax;
		}
		if (kachel.equals(getKachelX(1))) {
			// untere rechte Ecke der Kachel1 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeUntenRechts(getKachelX(1));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kachelbreite) / (rMax - kachelbreite)) * tmax;
		}
		// Bedingung fÃ¼r kachel2
		if (kachel.equals(getKachelX(2))) {
			// alle Knoten, die in dem oberen Bereich der Kachel liegen (~oberes
			// 1/3)
			Position p = this.kachelToKachelMitteOben(getKachel(this.node));
			double d1 = this.node.getPosition().yCoord
					- getKachelPosition(this.node).yCoord;
			double d2 = this.node.getPosition().distanceTo(p);
			if (d1 <= rMax - kachelbreite) {
				t = (d2 / Math.sqrt((Math.pow(rMax - kachelbreite, 2) + Math
						.pow(kachelbreite / 2, 2)))) * tmax;
				// log.logln(""+this.ID+": "+t);
			}
		}
		// Bedingung fÃ¼r kachel3
		if (kachel.equals(getKachelX(3))) {
			// untere linke Ecke der Kachel3 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeUntenLinks(getKachelX(3));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kachelbreite) / (rMax - kachelbreite)) * tmax;
		}
		// Bedingung fÃ¼r kachel4
		if (kachel.equals(getKachelX(4))) {
			// untere linke Ecke der Kachel4 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeUntenLinks(getKachelX(4));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kacheldiagonale) / (rMax - kacheldiagonale)) * tmax;
		}
		// Bedingung fÃ¼r kachel5
		if (kachel.equals(getKachelX(5))) {
			// untere rechte Ecke der Kachel5 fÃ¼r Distanzberechnung
			Position p = kachelToKachelEckeUntenRechts(getKachelX(5));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kachelbreite) / (rMax - kachelbreite)) * tmax;
		}
		// Bedingung fÃ¼r kachel6
		if (kachel.equals(getKachelX(6))) {
			// untere rechte Ecke der Kachel6 fÃ¼r Distanzberechnung
			Position p = kachelToKachelEckeUntenRechts(getKachelX(6));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = (d / kacheldiagonale) * tmax;
		}
		// Bedingung fÃ¼r kachel7
		// alle Knoten der Kachel
		if (kachel.equals(getKachelX(7))) {
			Position p = this.kachelToKachelMitteOben(getKachel(this.node));
			double d = this.node.getPosition().distanceTo(p);
			t = (d / Math.sqrt((Math.pow(kachelbreite, 2) + Math.pow(
					kachelbreite / 2, 2)))) * tmax;
			// log.logln(""+this.ID+": "+t);
		}
		// Bedingung fÃ¼r kachel8
		if (kachel.equals(getKachelX(8))) {
			// untere linke Ecke der Kachel8 fÃ¼r Distanzberechnung
			Position p = kachelToKachelEckeUntenLinks(getKachelX(8));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = (d / kacheldiagonale) * tmax;
		}
		// Bedingung fÃ¼r kachel9
		if (kachel.equals(getKachelX(9))) {
			// untere rechte Ecke der Kachel9 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeUntenLinks(getKachelX(9));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kachelbreite) / (kacheldiagonale - kachelbreite))
						* tmax;
		}
		// Bedingung fÃ¼r kachel10
		if (kachel.equals(getKachelX(10))) {
			// alle Knoten, die in dem linken Bereich der Kachel liegen (~linkes
			// 1/3)
			Position p = this.kachelToKachelMitteLinks(getKachel(this.node));
			double d1 = this.node.getPosition().xCoord - p.xCoord;
			double d2 = this.node.getPosition().distanceTo(p);
			if (d1 <= rMax - kachelbreite) {
				t = (d2 / Math.sqrt((Math.pow(rMax - kachelbreite, 2) + Math
						.pow(kachelbreite / 2, 2)))) * tmax;
				// log.logln(""+this.ID+": Kachel 8 "+t);
			}
		}

		// Bedingung fÃ¼r kachel11
		if (kachel.equals(getKachelX(11))) {
			// alle Knoten der Kachel
			Position p = this.kachelToKachelMitteLinks(getKachel(this.node));
			double d = this.node.getPosition().distanceTo(p);
			t = (d / Math.sqrt((Math.pow(kachelbreite, 2) + Math.pow(
					kachelbreite / 2, 2)))) * tmax;
			// log.logln(""+this.ID+": Kachel 9 "+t);
		}

		// Bedingung fÃ¼r kachel12 fÃ¤llt weg, eigene Kachel

		// Bedingung fÃ¼r Kachel13
		if (kachel.equals(getKachelX(13))) {
			// alle Knoten
			Position p = this.kachelToKachelMitteRechts(getKachel(this.node));
			double d = this.node.getPosition().distanceTo(p);
			t = (d / Math.sqrt((Math.pow(kachelbreite, 2) + Math.pow(
					kachelbreite / 2, 2)))) * tmax;
			// log.logln(""+this.ID+": Kachel 11 "+t);
		}

		// Bedingung fÃ¼r Kachel14
		if (kachel.equals(getKachelX(14))) {
			// alle Knoten, die in dem rechten Bereich der Kachel liegen
			// (~linkes 1/3)
			Position p = this.kachelToKachelMitteRechts(getKachel(this.node));
			double d1 = p.xCoord - this.node.getPosition().xCoord;
			double d2 = this.node.getPosition().distanceTo(p);
			if (d1 <= rMax - kachelbreite) {
				t = (d2 / Math.sqrt((Math.pow(rMax - kachelbreite, 2) + Math
						.pow(kachelbreite / 2, 2)))) * tmax;
				// log.logln(""+this.ID+": Kachel 12 "+t);
			}
		}
		// Bedingung fÃ¼r kachel15
		if (kachel.equals(getKachelX(15))) {
			// obere rechte Ecke der Kachel15 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeObenRechts(getKachelX(15));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kachelbreite) / (kacheldiagonale - kachelbreite))
						* tmax;
		}
		// Bedingung fÃ¼r kachel16
		if (kachel.equals(getKachelX(16))) {
			// obere rechte Ecke der Kachel16 fÃ¼r Distanzberechnung
			Position p = kachelToKachelEckeObenRechts(getKachelX(16));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = (d / (kachelbreite)) * tmax;
		}
		// Bedingung fÃ¼r kachel17
		if (kachel.equals(getKachelX(17))) {
			Position p = this.kachelToKachelMitteUnten(getKachel(this.node));
			double d = this.node.getPosition().distanceTo(p);
			t = (d / Math.sqrt((Math.pow(kachelbreite, 2) + Math.pow(
					kachelbreite / 2, 2)))) * tmax;
			// log.logln(""+this.ID+": "+t);
		}
		// Bedingung fÃ¼r kachel18
		if (kachel.equals(getKachelX(18))) {
			// obere linke Ecke der Kachel18 fÃ¼r Distanzberechnung
			Position p = kachelToKachelEckeObenLinks(getKachelX(18));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = (d / (kachelbreite)) * tmax;
		}
		// Bedingung fÃ¼r kachel19
		if (kachel.equals(getKachelX(19))) {
			// obere linke Ecke der Kachel19 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeObenLinks(getKachelX(19));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kachelbreite) / (kacheldiagonale - kachelbreite))
						* tmax;
		}
		// Bedingung fÃ¼r kachel20
		if (kachel.equals(getKachelX(20))) {
			// obere rechte Ecke der Kachel20 fÃ¼r Distanzberechnung
			Position p = kachelToKachelEckeObenRechts(getKachelX(20));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kacheldiagonale) / (rMax - kacheldiagonale)) * tmax;
		}
		// Bedingung fÃ¼r kachel21
		if (kachel.equals(getKachelX(21))) {
			// obere rechte Ecke der Kachel21 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeObenRechts(getKachelX(21));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kachelbreite) / (kacheldiagonale - kachelbreite))
						* tmax;
		}
		// Bedingung fÃ¼r kachel22
		if (kachel.equals(getKachelX(22))) {
			// alle Knoten, die in dem unteren Bereich der Kachel liegen
			// (~oberes 1/3)
			Position p = this.kachelToKachelMitteUnten(getKachel(this.node));
			double d1 = p.yCoord - this.node.getPosition().yCoord;
			double d2 = this.node.getPosition().distanceTo(p);
			if (d1 <= rMax - kachelbreite) {
				t = (d2 / Math.sqrt((Math.pow(rMax - kachelbreite, 2) + Math
						.pow(kachelbreite / 2, 2)))) * tmax;
				// log.logln(""+this.ID+": "+t);
			}
		}
		// Bedingung fÃ¼r kachel23
		if (kachel.equals(getKachelX(23))) {
			// obere linke Ecke der Kachel23 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeObenLinks(getKachelX(23));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kachelbreite) / (kacheldiagonale - kachelbreite))
						* tmax;
		}
		// Bedingung fÃ¼r kachel24
		if (kachel.equals(getKachelX(24))) {
			// obere linke Ecke der Kachel24 fÃ¼r Distanzberechnung
			// minus Kachelbreite, damit grÃ¶Ãere Unterscheidung im timer-Wert
			Position p = kachelToKachelEckeObenLinks(getKachelX(24));
			double d = this.node.getPosition().distanceTo(p);
			if (d <= rMax)
				t = ((d - kacheldiagonale) / (rMax - kacheldiagonale)) * tmax;
		}
		return t;
	}
	
	/**
	 * @param kachel eine Kachel z.B. (1,1,0)
	 * @return true, die Kachel im Array aktiveKacheln enthalten ist.
	 */
	public boolean isInAktiveKacheln(Position kachel) {
		if (kachel != null && activeCells != null) {
			for (int i = 0; i < activeCells .length; i++) {
				if (activeCells [i] != null && activeCells [i].equals(kachel))
					return true;
			}
		}
		return false;
	}

	/**
	 * @return true, wenn das Array aktiveKacheln leer sein sollte.
	 */
	public boolean isAktiveKachelnLeer() {
		if (activeCells != null) {
			for (int i = 0; i < activeCells.length; i++) {
				if (activeCells[i] != null)
					return false;
			}
		}
		return true;
	}
}
