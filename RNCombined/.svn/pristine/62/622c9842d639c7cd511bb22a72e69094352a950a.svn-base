package projects.reactiveSpanner.nodes.messageHandlers;

import java.util.HashMap;

import projects.reactiveSpanner.exceptions.InvalidBeaconlessSubgraphStrategyException;
import projects.reactiveSpanner.nodes.messageHandlers.SubgraphStrategy.EStrategy;
import projects.reactiveSpanner.nodes.messageHandlers.BCA.BCA;
import projects.reactiveSpanner.nodes.messageHandlers.BFP.BFP;
import projects.reactiveSpanner.nodes.messageHandlers.Barriere.Barriere;
import projects.reactiveSpanner.nodes.messageHandlers.BarriereExt.BarriereExt;
import projects.reactiveSpanner.nodes.messageHandlers.buildBackbone.BuildBackbone;
import projects.reactiveSpanner.nodes.messageHandlers.buildBackbone.CreateVirtuals;
import projects.reactiveSpanner.nodes.messageHandlers.reactivePDT.ReactivePDT;
import projects.reactiveSpanner.nodes.messageHandlers.simpleTopologyControls.LocalGG;
import projects.reactiveSpanner.nodes.messageHandlers.simpleTopologyControls.LocalPDT;
import projects.reactiveSpanner.nodes.messageHandlers.simpleTopologyControls.LocalUDG;
import projects.reactiveSpanner.nodes.nodeImplementations.PhysicalGraphNode;
import sinalgo.tools.Tools;
import sinalgo.tools.logging.LogL;
import sinalgo.tools.logging.Logging;

/**
 * Factory of subgraph strategies that are called on the holder of this class. This factory manages if there is already a requested subgraph strategy or if it has to be created. So, for each type of subgraph strategy only one instance will be created.
 * 
 * @author Mavs
 */
public class SubgraphStrategyFactory {
	private static Logging logger = Logging.getLogger();
	/**
	 * Number of nodes in the graph. Used to determine if the number has changed and therefore a new subgraphStrategy should be calculated
	 */
	private int numberNodesInGraph;
	final private PhysicalGraphNode holder;
	private HashMap<EStrategy, SubgraphStrategy> topologyControls;

	/**
	 * The last subgraph strategy that was started by the holder
	 */
	private SubgraphStrategy lastSubgraphStrategy;

	public SubgraphStrategyFactory(final PhysicalGraphNode holder) {
		this.holder = holder;
		this.numberNodesInGraph = Tools.getNodeList().size();
		topologyControls = new HashMap<SubgraphStrategy.EStrategy, SubgraphStrategy>();
	}

	/**
	 * Send an request for a desired topology control. If this topology control was already generated, the one will be returned, otherwise a new one will be generated. In both cases, the subclass strategy will be returned.
	 * 
	 * @param <T>
	 * 
	 * @param controlStrategy
	 *            requested subgraph strategy represented by the enumeration.
	 * @return requested SubgraphStrategy
	 */
	public SubgraphStrategy request(final EStrategy controlStrategy)
	{
		if(!isGraphUpToDate())
		{
			topologyControls.clear();
		}
		
		if (!topologyControls.containsKey(controlStrategy)) {
			SubgraphStrategy newSubgraphStrategy = null;
			switch (controlStrategy) {
			case BARRIERE:
				newSubgraphStrategy = new Barriere(holder);
				break;
			case BARRIERE_EXT:
				newSubgraphStrategy = new BarriereExt(holder);
				break;
			case BFP:
				newSubgraphStrategy = new BFP(holder);
				break;
			case BUILD_BACKBONE:
				newSubgraphStrategy = new BuildBackbone(holder);
				break;
			case CREATE_VIRTUALS:
				newSubgraphStrategy = new CreateVirtuals(holder, topologyControls.get(EStrategy.BUILD_BACKBONE).getTopologyControlID());//FIXME hack to test. Need to find a better solution: 																															//a Subgraphstrategy must be able to invoke another one.
				break;
			case REACTIVE_PDT:
				newSubgraphStrategy = new ReactivePDT(holder);
				break;
			case BCA:
				newSubgraphStrategy = new BCA(holder);
				break;
			case UDG:
				newSubgraphStrategy = new LocalUDG(holder);
				break;
			case GG:
				newSubgraphStrategy = new LocalGG(holder);
				break;
			case PDT:
				newSubgraphStrategy = new LocalPDT(holder);
				break;
			default:
				throw new InvalidBeaconlessSubgraphStrategyException("No or invalid selected control strategy!");
			}
			topologyControls.put(controlStrategy, newSubgraphStrategy);
			lastSubgraphStrategy = newSubgraphStrategy;
			return lastSubgraphStrategy;
		} else {
			lastSubgraphStrategy = topologyControls.get(controlStrategy);
			return lastSubgraphStrategy;
		}
	}

	/**
	 * Checks whether the global graph has changed since the last request for this node
	 * @return graph has not changed
	 */
	private boolean isGraphUpToDate()
	{
		//TODO proving more features t detect changes
		return numberNodesInGraph == Tools.getNodeList().size();
	}

	/**
	 * @return The last requested subgraph strategy
	 */
	public SubgraphStrategy getLastRequestedSubgraphStrategy() {
		return lastSubgraphStrategy;
	}

	/**
	 * @param controlStrategy to be drawn
	 * draws controlStrategy if exists.
	 */
	public void drawSubgraphStrategy(EStrategy controlStrategy) {
		if (topologyControls.containsKey(controlStrategy)) {
			lastSubgraphStrategy = topologyControls.get(controlStrategy);
		} else {
			throw new RuntimeException("Cannot find controlStrategy: " + controlStrategy);
		}
	}

	/**
	 * Force the holding node to take the specified subgraphStrategy <br>
	 * This case is unusual use of subgraph strategies and should be only considered if its necessary to spread a single subgraphStrategy among different nodes
	 * 
	 * @param subgraphStrategy
	 *            that is forced to use
	 */
	public void handOverSubgraphStrategy(SubgraphStrategy subgraphStrategy) {
		if (topologyControls.containsKey(subgraphStrategy.getStrategyType())) {
			logger.logln(LogL.WARNING, "Subgraph Strategy controller of node " + holder.toString() + " is forced to take over subgraph strategy of type " + subgraphStrategy.getStrategyType() + " and ID " + subgraphStrategy.getTopologyControlID() + " but has already a subgraph strategy of this type. " + "The old strategy will be overwrited.");
		}
		topologyControls.put(subgraphStrategy.getStrategyType(), subgraphStrategy);
		numberNodesInGraph=Tools.getNodeList().size();
	}
}
