package projects.reactiveSpanner.nodes.messageHandlers.buildBackbone;

import java.awt.Graphics;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import org.jdom.output.EscapeStrategy;

import com.sun.org.apache.bcel.internal.generic.GOTO;

import projects.reactiveSpanner.CustomGlobal;
import projects.reactiveSpanner.Utilities;
import projects.reactiveSpanner.nodes.messageHandlers.AbstractMessageHandler;
import projects.reactiveSpanner.nodes.messageHandlers.BeaconTopologyControl;
import projects.reactiveSpanner.nodes.messageHandlers.SubgraphStrategy;
import projects.reactiveSpanner.nodes.messageHandlers.SubgraphStrategy.EStrategy;
import projects.reactiveSpanner.nodes.nodeImplementations.PhysicalGraphNode;
import projects.reactiveSpanner.nodes.nodeImplementations.SimpleNode;
import sinalgo.gui.transformation.PositionTransformation;
import sinalgo.nodes.Node;
import sinalgo.nodes.edges.Edge;
import sinalgo.tools.Tools;
import sinalgo.tools.logging.LogL;
import sun.awt.SubRegionShowable;

public class CreateVirtuals extends BeaconTopologyControl {

	/**
	 * connectionTopology defines the topologyControl from which the knownNeighbors are taken if null then take outgoingConnections of each node
	 */
	UUID connectionTopology;

	public CreateVirtuals(PhysicalGraphNode sourceNode, UUID connectionTopology) {
		super(EStrategy.CREATE_VIRTUALS, sourceNode);
		this.connectionTopology = connectionTopology;

	}

	@Override
	protected void _start() {

		for (PhysicalGraphNode p : Utilities.getNodeCollectionByClass(PhysicalGraphNode.class)) {

			CreateVirtualsMessageHandler cvmh;

			if (connectionTopology == null) {//if there is no topologycontrol specified which this topologycontrol should use, take outgoing connections

				Set<PhysicalGraphNode> cons = new HashSet<PhysicalGraphNode>();
				for (Edge e : p.outgoingConnections) {
					cons.add((PhysicalGraphNode) e.endNode); //TODO Tim, check if this would be an problem

				}
				cvmh = new CreateVirtualsMessageHandler(getTopologyControlID(), p, p, EStrategy.CREATE_VIRTUALS, cons);
			} else {
				//SubgraphStrategy strategy = p.requestSubgraph(EStrategy.BUILD_BACKBONE);  //does not work since the subgraph strategy only has one source node.
			     AbstractMessageHandler strategy=p.getMessageHandler(connectionTopology);																		//but I want to have the subgraphnodes of each node.
				cvmh = new CreateVirtualsMessageHandler(getTopologyControlID(), p, p, EStrategy.CREATE_VIRTUALS, strategy.getKnownNeighbors());
			
			}
			if (!sourceNode.equals(p)) {//filter holder
				p.subgraphStrategyFactory.handOverSubgraphStrategy(this);
			}

			p.messageHandlerMap.put(getTopologyControlID(), cvmh);//how are we supposed to do this?

			cvmh.start(); //TODO: REMOVE THIS
		}
	}

	@Override
	protected void _init() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void draw(Graphics g, PositionTransformation pt) {
		
		for (PhysicalGraphNode p : Utilities.getNodeCollectionByClass(PhysicalGraphNode.class)) {
			p.getMessageHandler(this.getTopologyControlID()).drawNode(g, pt);

		}//draw method of each createVirtuals messagehandler
	}

}
