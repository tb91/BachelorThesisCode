package projects.reactiveSpanner.nodes.messageHandlers.BCA;

import java.awt.Color;
import java.awt.Graphics;
import java.util.HashMap;

import projects.reactiveSpanner.CustomGlobal;
import projects.reactiveSpanner.nodes.messageHandlers.BeaconlessTopologyControl;
import projects.reactiveSpanner.nodes.messages.AbstractMessage;
import projects.reactiveSpanner.nodes.messages.BCA.FirstRequest;
import projects.reactiveSpanner.nodes.messages.BCA.FirstResponse;
import projects.reactiveSpanner.nodes.messages.BCA.SecondRequest;
import projects.reactiveSpanner.nodes.messages.BCA.SecondResponse;
import projects.reactiveSpanner.nodes.nodeImplementations.PhysicalGraphNode;
import projects.reactiveSpanner.nodes.timers.BCA.BCAMessageTimer;
import projects.reactiveSpanner.nodes.timers.BCA.FinishTimer;
import projects.reactiveSpanner.nodes.timers.BCA.FirstRequestPhaseDoneTimer;
import projects.reactiveSpanner.nodes.timers.BCA.SecondRequestTimer;
import projects.reactiveSpanner.record.MessageRecord;
import sinalgo.gui.transformation.PositionTransformation;
import sinalgo.models.ConnectivityModel;
import sinalgo.nodes.Node;
import sinalgo.nodes.Position;
import sinalgo.nodes.timers.Timer;
import sinalgo.runtime.Global;
import sinalgo.tools.Tools;
import sinalgo.tools.logging.LogL;
	
public class BCAForwarderMessageHandler extends BCAMessageHandler {

	public Timer secondRequestTimer;
	public FinishTimer finishTimer;
	
	public boolean phase2 = false;
	
	private PhysicalGraphNode[] nArray = new PhysicalGraphNode[25];
	private HashMap<PhysicalGraphNode, Position> hm = new HashMap<PhysicalGraphNode, Position>();
	{
		hm.put(this.node, getKachel(node));
		putArray(this.node);
	}
	
	public BCAForwarderMessageHandler(final BeaconlessTopologyControl subgraphControl, PhysicalGraphNode sourceNode) {
		super(subgraphControl.getTopologyControlID(), sourceNode, sourceNode);
	}
	
	public void broadcastFirstRequest() {
		
		logger.logln(LogL.INFO, "Round " + Global.currentTime + ": SourceNode "
				+ this.node.toString()
				+ " broadcasts FirstRequest to topology control ID "
				+ this.tcID.toString());
		firstRequestTimer = new BCAMessageTimer(new FirstRequest(this.tcID,
				this.node, getDirectCells()));
		firstRequestTimer.startRelative(1, node);
		
		// Im Originalcode war von tmax+3 die Rede, doch ich sende den FirstRequest
		// erst in der nächsten Runde aus.
		broadcastSecondRequest(tmax+4);
		this.node.setColor(Color.RED);
		
		firstRequestPhaseDoneTimer = new FirstRequestPhaseDoneTimer(this);
		firstRequestPhaseDoneTimer.startRelative(firstRequestTimer.getFireTime() + tmax + 5, this.node);
		
		// Setze FinishTimer
		finishTimer = new FinishTimer(this);
		finishTimer.startRelative(3 * tmax + 8, this.node);
		
		// UDG oder QUDG?
		String cm = this.node.getConnectivityModel().getClass().getName();
		String UDG = ConnectivityModel.getConnectivityModelInstance("UDG").getClass()
				.getName();
//		String QUDG = ConnectivityModel.getConnectivityModelInstance("StaticQUDG")
//				.getClass().getName();

		if (cm.equals(UDG)) {
			rMin = udr;
			rMax = rMin;
		}

		hm.put(this.node, getKachel(this.node));
		putArray(this.node);

		if (cm.equals(UDG)) {
			PhysicalGraphNode dummy = this.node;
			nArray[0] = dummy;
			nArray[4] = dummy;
			nArray[20] = dummy;
			nArray[24] = dummy;
		}
	}
	
	public void broadcastSecondRequest(double timer) {
		
		logger.logln(LogL.INFO, "Round " + Global.currentTime + ": SourceNode " + this.node.toString()
				+ " broadcasts SecondRequest to topology control ID "
				+ this.tcID.toString() + " in " + timer + " rounds");
		
		secondRequestTimer = new SecondRequestTimer(this);
		secondRequestTimer.startRelative(timer - 1, this.node);
	}
	
	public void broadcastSecondRequestNow(){
		boolean openCells = false;
		
		Position[] indirectCells = new Position[nArray.length];
		for (int i = 0; i < nArray.length; i++) {
			if (nArray[i] == null && indirectCells[i] == null) {
				indirectCells[i] = getKachelX(i);
				openCells = true;
			}
		}
		
		if (openCells) {
			secondRequestTimer = new BCAMessageTimer(new SecondRequest(this.tcID,
					this.node, indirectCells));
			secondRequestTimer.startRelative(1, this.node);
		}
	}
	
	@Override
	public void receivedMessage(AbstractMessage msg) {
		if (msg instanceof FirstResponse) {
			receivedFirstResponse((FirstResponse) msg);
		}
		
		if (msg instanceof SecondResponse) {
			receivedSecondResponse((SecondResponse) msg);
		}
		
		if (msg instanceof FirstRequest) {
			if (finishTimer != null) {
				finishTimer.disable();
				finishTimer = new FinishTimer(this);
				finishTimer.startRelative(2 * tmax + 4, this.node);
			}
		}
	}
	
	@Override
	public void receivedFirstResponse(FirstResponse msg) {
		
		logger.logln(LogL.INFO, "Round " + Global.currentTime + ": SourceNode " + this.node.toString()
				+ " received FirstResponse from Node " + msg.getSource().toString());
		
		PhysicalGraphNode n = msg.getSource();
		Position cell = getKachel(n);
		if (!hm.containsValue(cell)) {
			hm.put(n, cell);
			putArray(n);
			this.knownNeighbors.add(n);

			//TODO Kante von diesem Knoten zu msg.getSource()
			n.setColor(Color.RED);
		}
	}
	
	@Override
	public void receivedSecondResponse(SecondResponse msg) {
		
		logger.logln(LogL.INFO, "Round " + Global.currentTime + ": SourceNode " + this.node.toString()
				+ " received SecondResponse from Node " + msg.getNode().toString());
		
		PhysicalGraphNode n = msg.getSource();
		Position cell = getKachel(n);
		if (!hm.containsValue(cell)) {
			hm.put(n, cell);
			putArray(msg.getSource());
			this.knownNeighbors.add(msg.getSource());
			
			n.setColor(Color.RED);
			
			//TODO Kante von diesem Knoten zu msg.getNode() zeichnen
			//TODO Kante von msg.getSource() zu msg.getNode() zeichnen
			msg.getNode().setColor(Color.RED);
		}		
	}
	
	public void done(){

		String str = "Knoten " + this.node.ID
				+ ": FERTIG! Folgende Kacheln sind nicht erreichbar: ";
		for (int i = 0; i < nArray.length; i++) {
			if (nArray[i] == null)
				str = str + i + ",";
		}
		logger.logln(str);
		Tools.stopSimulation();
		
		boolean b = true;
		for (Node n : nArray) {
			if (n == null)
				b = false;
		}
		
		if (b) {
			logger.logln("Knoten " + this.node.ID
					+ ": FERTIG! Es sind keine offenen Kacheln Ã¼brig.");
			Tools.stopSimulation();
		}
		
		System.out.println("	Gefundene Knoten: " + this.knownNeighbors.toString());
		System.out.println();
		System.out.println("  Nachrichten: 		" + CustomGlobal.totalMessages);
		System.out.println("  FirstRequests:	" + CustomGlobal.firstRequests);
		System.out.println("  FirstResponses:	" + CustomGlobal.firstResponses);
		System.out.println("  SecondRequests:	" + CustomGlobal.secondRequests);
		System.out.println("  SecondResponses:	" + CustomGlobal.secondResponses);
		System.out.println();
		System.out.println("FirstRequestNodes:   " + CustomGlobal.firstRequestNodes.toString());
		System.out.println("FirstResponseNodes:  " + CustomGlobal.firstResponseNodes.toString());
		System.out.println("SecondResponseNodes: " + CustomGlobal.secondResponseNodes.toString());
	}

	@Override
	public void drawNode(Graphics g, PositionTransformation pt) {
		this.node.setColor(Color.RED);
	}

	@Override
	public MessageRecord getCurrentMessageRecord() {
		// Auto-generated method stub
		return null;
	}
	
	public void putArray(PhysicalGraphNode n) {
		for (int i=0;i<=24;i++){
			if(getKachel(n).equals(getKachelX(i))) nArray[i]=n;
		}
	}
	
}
