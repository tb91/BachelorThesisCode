#!/usr/bin/perl
# (C) Matthias von Steimker - 2014
#
# This software is written under the Software libre para Uso Civil (SLUC) license
#
# You can use it for any other purpose, copy, modify, and always trade with the copies 
# and redistribute modifications in respect to the SLUC license.
#
# A copy of the Software libre para Uso Civil License can be found in the file license_sluc.txt 
# The license is also available at http://www.sluc.info (both in spanish language).
#
# This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Also the use of this software is prohibited to military personnel and to personnel 
# in industries creating offensive weapons.
# See the Software libre para Uso Civil License (in spanish language) for more details.



# This script is used to validate the of the data generated by generateSamples-BFP_rPDT.pl
# Validated will be the following:
# * neighbors of the UDG >= neighbors of the PDT
# * neighbors of the PDT >= neighbors of the GG
# * neighbors of the GG == sent CTS + Protest messages of the BFP
# * neighbors of the PDT == sent CTS of the rPDT
# * sent RTS of BFP and rPDT are 1

# using strictly defined variables only
use strict;
use warnings;
# warn user (from perspective of caller)
use Carp;

################
#STARTING POINT#
################
#parsing of the files
foreach (@ARGV)
{
	my($filepath) = $_;
	if (readFileAndValidateVals($filepath) == 0)
	{
		print "File $filepath has been successfully validated!\n"; 
	} else {
		print "File $filepath contains unexpected and possibly faulty data!\n";
	}
}
exit;
##############
#ENDING POINT# 
##############

# read a file in fixed form and save values in hashmaps with densities as keys
sub readFileAndValidateVals {
	my ($filepath) = @_;
	unless (defined $filepath)
	{
		die "readFileAndValidateVals needs an argument!";
	}
	#do not continue if file does not exist
	unless(-e $filepath)
	{
		die "No file of given filepath $filepath exists! \n";
	}
	#open file in reading mode
	open (FILE, "<" , $filepath) or die "Cannot read the input file $filepath! \n";
	my $lineNumber = 0;
	my $error = 0; #is set to 1 if something went wrong
	while (<FILE>) 
	{
		chomp; # kill newlines
		s/^\s+//;  # remove leading whitespace
    	s/\s+$//; # remove trailing whitespace
    	next unless length; # next rec unless anything left

		$lineNumber++;
		my ($density, $numNodes, $neighborsUDG, $neighborsGG, $neighborsPDT, $BFP_RTS, $BFP_CTS, $BFP_Protest, $rPDT_RTS, $rPDT_CTS, $seed, $forwarderNode) = split(",");
		# we do not use $seed and $forwarderNode here
		# print "Pushing number of neighbors UDG = $neighborsUDG to map with density $density \n";

		unless ($neighborsUDG >= $neighborsPDT)
		{
			print "Number of PDT neighbors is greater than the number of UDG neighbors for data set at line $lineNumber of file $filepath!\n";
			$error = 1;
		}
		unless ($neighborsPDT >= $neighborsGG)
		{
			print "Number of GG neighbors is greater than the number of PDT neighbors for data set at line $lineNumber of file $filepath!\n";
			$error = 1;
		}
		unless( $neighborsGG == ($BFP_CTS - $BFP_Protest))
		{
			print "Number of GG neighbors does not equal the number of sent CTS deducted by number of sent protest messages of BFP for data set at line $lineNumber of file $filepath!\n";
			$error = 1;
		}
		unless( $neighborsPDT == $rPDT_CTS)
		{
			print "Number of PDT neighbors does not equal the number of sent CTS of reactive PDT for data set at line $lineNumber of file $filepath!\n";
			$error = 1;
		}
		unless ($BFP_RTS == 1 && $rPDT_RTS == 1)
		{
			print "BFP or reactive PDT has not sent an RTS at data set at line $lineNumber of file $filepath!\n";
			$error = 1;
		}
	}
	close (FILE);
	return $error;
}