#!/usr/bin/perl
# (C) Matthias von Steimker - 2014
#
# This software is written under the Software libre para Uso Civil (SLUC) license
#
# You can use it for any other purpose, copy, modify, and always trade with the copies 
# and redistribute modifications in respect to the SLUC license.
#
# A copy of the Software libre para Uso Civil License can be found in the file license_sluc.txt 
# The license is also available at http://www.sluc.info (both in spanish language).
#
# This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Also the use of this software is prohibited to military personnel and to personnel 
# in industries creating offensive weapons.
# See the Software libre para Uso Civil License (in spanish language) for more details.



# This script is used to calculate confidence intervals of the of the data generated by generateSamples-BFP_rPDT.pl
# The result will be saved in a easy to read file defined by the $DEBUG_OUTPATH and in the GNU_OUTPATH that is easy to
# handle with Gnuplot to plot the data. Data will be summarized and the mean will be calculated. Also lower and upper bound 
# of the confidence intervall will be saved
# The Data in the GNU_OUTPATH will be saved in the format VALUE_NAME mean upper_bound lower_bound
# Therefore a dataset for a value is represented by 4 values. The VALUE_NAME is only used to show what the following three values represents

# using strictly defined variables only
use strict;
use warnings;
# warn user (from perspective of caller)
use Carp;

my $MARGIN_ERROR = 1.96;
my $DEBUG_OUTPATH = "./tmp/debug_confiIntervals-Routing.csv";
my $GNU_OUTPATH = "./tmp/data_faceR_GFG.dat";

my $IN_SPLIT_CHAR = ",";
my $OUT_SPLIT_CHAR = " ";

################
#STARTING POINT#
################
#initialize maps for all the value types that are stored in the file
my %mapNumNodes = ();
my %mapEuclDistance = ();
my %mapEuclDistance_UDG_min = ();
my %mapHopDistance_UDG_min = ();
my %mapEuclDistance_GG_min = ();
my %mapHopDistance_GG_min = ();
my %mapEuclDistance_PDT_min = ();
my %mapHopDistance_PDT_min = ();
my %mapEuclDistance_FaceR_GG = ();
my %mapHopDistance_FaceR_GG = ();
my %mapEuclDistance_FaceR_PDT = ();
my %mapHopDistance_FaceR_PDT = ();
my %mapEuclDistance_GFG_GG = ();
my %mapHopDistance_GFG_GG = ();
my %mapEuclDistance_GFG_PDT = ();
my %mapHopDistance_GFG_PDT = ();

my %mapNumDataSamples = ();

# print OUT "$_:\n" or die "Something went wrong during writing to $DEBUG_OUTPATH. Aborted.\n";
#parsing of the files
foreach (@ARGV)
{
	#system("perl validateData-FaceR_GFG.pl $_"); #validate the data before calculating confidence intervals
	readFileAndSaveValsInHashMaps($_);
}
#saveToDebugFile();
saveToGNUPlotConformFile();
exit;
##############
#ENDING POINT# 
##############

# read a file in fixed form and save values in hashmaps with densities as keys
sub readFileAndSaveValsInHashMaps {
	my ($filepath) = @_;
	unless (defined $filepath)
	{
		die "readFileAndSaveValsInHashMaps needs an argument!";
	}
	#do not continue if file does not exist
	unless(-e $filepath)
	{
		die "No file of given filepath $filepath exists! \n";
	}
	print "Parsing file \"" . $filepath . "\"... \n";

	#open file in reading mode
	open (FILE, "<" , $filepath) or die "Cannot read the input file $filepath! \n";
	while (<FILE>) 
	{
		chomp; # kill newlines
		s/^\s+//;  # remove leading whitespace
    	s/\s+$//; # remove trailing whitespace
    	next unless length; # next rec unless anything left

		my ($density, $numNodes, $minEuclDis, $minEuclDis_UDG, $minHopDis_UDG, $minEuclDis_GG, $minHopDis_GG, $minEuclDis_PDT, $minHopDis_PDT, $euclDis_FaceR_GG, $hopDis_FaceR_GG, $euclDis_FaceR_PDT, $hopDis_FaceR_PDT, $euclDis_GFG_GG, $hopDis_GFG_GG, $euclDis_GFG_PDT, $hopDis_GFG_PDT, $sourceNode, $destinationNode, $seed) = split($IN_SPLIT_CHAR);
		# we do not use $sourceNode, $destinationNode and $seed here
		# print "Pushing number of neighbors UDG = $neighborsUDG to map with density $density \n";
		push(@{$mapNumNodes{$density}}, $numNodes);
		push(@{$mapEuclDistance{$density}}, $minEuclDis);
		push(@{$mapEuclDistance_UDG_min{$density}}, $minEuclDis_UDG);
		push(@{$mapHopDistance_UDG_min{$density}}, $minHopDis_UDG);
		push(@{$mapEuclDistance_GG_min{$density}}, $minEuclDis_GG);
		push(@{$mapHopDistance_GG_min{$density}}, $minHopDis_GG);
		push(@{$mapEuclDistance_PDT_min{$density}}, $minEuclDis_PDT);
		push(@{$mapHopDistance_PDT_min{$density}}, $minHopDis_PDT);
		push(@{$mapEuclDistance_FaceR_GG{$density}}, $euclDis_FaceR_GG);
		push(@{$mapHopDistance_FaceR_GG{$density}}, $hopDis_FaceR_GG);
		push(@{$mapEuclDistance_FaceR_PDT{$density}}, $euclDis_FaceR_PDT);
		push(@{$mapHopDistance_FaceR_PDT{$density}}, $hopDis_FaceR_PDT);
		push(@{$mapEuclDistance_GFG_GG{$density}}, $euclDis_GFG_GG);
		push(@{$mapHopDistance_GFG_GG{$density}}, $hopDis_GFG_GG);
		push(@{$mapEuclDistance_GFG_PDT{$density}}, $euclDis_GFG_PDT);
		push(@{$mapHopDistance_GFG_PDT{$density}}, $hopDis_GFG_PDT);

		my $val;
		if (defined $mapNumDataSamples{$density})
		{
			$val = $mapNumDataSamples{$density} + 1;
		} else {
			$val = 1;
		}
		$mapNumDataSamples{$density} = $val;	
	}
	close (FILE);
}
# calculate and return the mean of a given array
sub calculateMean {
	my $sumedUp = 0;
	foreach my $element (@_)
	{
		$sumedUp += $element;
	}
	return $sumedUp / scalar(@_);
}
# calculate and return the variance of a given array
sub calculateVariance {
	my $mean = calculateMean(@_);
	my $sumedUp = 0;
	foreach my $element (@_)
	{
		$sumedUp += ($element - $mean) * ($element - $mean);
	}
	return $sumedUp / scalar(@_);
}
# calculate and return the upper bound of confidence interval of the three given arguments mean, standard deviation and number of elements
sub calculateUpperBound {
	my ($mean, $standardDeviation, $n) = @_;	
	return $mean + $MARGIN_ERROR * ($standardDeviation / sqrt($n));
}
# calculate and return the lower bound of confidence interval of the three given arguments mean, standard deviation and number of elements
sub calculateLowerBound {
	my ($mean, $standardDeviation, $n) = @_;	
	return $mean - $MARGIN_ERROR * ($standardDeviation / sqrt($n));
}
# printing result to file
sub printToOutputFile{
	my ($valName, $density, $mean, $lowerBound, $upperBound) = @_;
	
	unless (defined($valName) && defined($density) && defined($upperBound) && defined($lowerBound))
	{
		die "printToOutputFile: has not enough arguments!";
	}
	unless (index($valName, $OUT_SPLIT_CHAR) == -1)
	{
		die "printToOutputFile: Data separation character \'$OUT_SPLIT_CHAR\' is contained in value name \"$valName\"! Please change the name of this value.";
	}
	print OUT "$valName$OUT_SPLIT_CHAR$mean$OUT_SPLIT_CHAR$lowerBound$OUT_SPLIT_CHAR$upperBound" or die "Something went wrong during writing to file. Aborted.\n";
}
# Actual subroutine for calculation of the confidence intervals and print them to file
# @[0]: name of data for that the confidence intervals should be calculated
# @[1]: node density that is corresponded with the given values
# @[2]: array for actual data
sub estimateConfidenceIntervals {
	my ($name, $density, @values) = @_;

	my $mean = calculateMean(@values);
	my $standardDeviation = sqrt(calculateVariance(@values));

	#calculate confidence intervals
	my $lowerBound = calculateLowerBound( $mean, $standardDeviation, scalar(@values) );
	my $upperBound = calculateUpperBound( $mean, $standardDeviation, scalar(@values) );
	print "$name: Lower bound: $lowerBound \n";
	print "$name: Upper bound: $upperBound \n";
	printToOutputFile($name, $density, $mean, $lowerBound, $upperBound);
}

sub printNumDataSamples {
	foreach my $density ( sort {$a <=> $b} keys %mapNumNodes ) #presumption: all maps have the same keys
	{
	}
}

sub saveToDebugFile {
#open OUT in overwriting mode
open(OUT, ">", $DEBUG_OUTPATH) or die "Cannot read/write the output file $DEBUG_OUTPATH\n";
my $error_write_msg = "Something went wrong during writing to $DEBUG_OUTPATH. Aborted.\n";
#calculation of the confidence intervals of all value pairs per value type
foreach my $density ( sort {$a <=> $b} keys %mapNumNodes ) #presumption: all maps have the same keys
{
	print OUT "Density $density with $mapNumDataSamples{$density} data samples:\n" or die "$error_write_msg";
	estimateConfidenceIntervals("Number_of_Nodes", $density, @{$mapNumNodes{$density}});
	print OUT "\n" or die "$error_write_msg";  
	estimateConfidenceIntervals("min_Eucl_Distance", $density, @{$mapEuclDistance{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("min_eucl_Distance_UDG", $density, @{$mapEuclDistance_UDG_min{$density}});
	print OUT "\n" or die "$error_write_msg";  
	estimateConfidenceIntervals("min_hop_Distance_UDG", $density, @{$mapHopDistance_UDG_min{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("min_eucl_Distance_GG", $density, @{$mapEuclDistance_GG_min{$density}});
	print OUT "\n" or die "$error_write_msg";  
	estimateConfidenceIntervals("min_hop_Distance_GG", $density, @{$mapHopDistance_GG_min{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("min_eucl_Distance_PDT", $density, @{$mapEuclDistance_PDT_min{$density}});
	print OUT "\n" or die "$error_write_msg";  
	estimateConfidenceIntervals("min_hop_Distance_PDT", $density, @{$mapHopDistance_PDT_min{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("eucl_Distance_FaceR_GG", $density, @{$mapEuclDistance_FaceR_GG{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("hop_Distance_FaceR_GG", $density, @{$mapHopDistance_FaceR_GG{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("eucl_Distance_FaceR_PDT", $density, @{$mapEuclDistance_FaceR_PDT{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("hop_Distance_FaceR_PDT", $density, @{$mapHopDistance_FaceR_PDT{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("eucl_Distance_GFG_GG", $density, @{$mapEuclDistance_GFG_GG{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("hop_Distance_GFG_GG", $density, @{$mapHopDistance_GFG_GG{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("eucl_Distance_GFG_PDT", $density, @{$mapEuclDistance_GFG_PDT{$density}});
	print OUT "\n" or die "$error_write_msg";
	estimateConfidenceIntervals("hop_Distance_GFG_PDT", $density, @{$mapHopDistance_GFG_PDT{$density}});
	print OUT "\n\n" or die "$error_write_msg";
}
close(OUT);
print "Finished writing to Debug file \"$DEBUG_OUTPATH\" successfully!\n\n";
}

sub twoArraySum{
	my ( $aRef, $bRef ) = @_;
	my  @result = ();

	unless (scalar(@{$aRef}) == scalar(@{$bRef}))
	{
		die "twoArraySum: Number of elements in given arrays is not equal!";
	}

    my $idx = 0;
    foreach my $aItem (@{$aRef}) {
        my $bItem = $bRef->[$idx++];
        push (@result, $aItem + $bItem);
    }
    return @result;
}
#Attention: result could have less values than input arrays because if a value of the second array is zero, no result value will be calculated
sub twoArrayDiv{
	my ( $aRef, $bRef ) = @_;
	my  @result = ();

	unless (scalar(@{$aRef}) == scalar(@{$bRef}))
	{
		die "twoArraySum: Number of elements in given arrays is not equal!";
	}

    my $idx = 0;
    foreach my $aItem (@{$aRef}) {
        my $bItem = $bRef->[$idx++];
        if($bItem != 0)
        {
        	push (@result, $aItem / $bItem);
        }
         
    }
    return @result;
}

#
sub saveToGNUPlotConformFile {
#open OUT in overwriting mode
open(OUT, ">", $GNU_OUTPATH) or die "Cannot read/write the output file $GNU_OUTPATH\n";
my $error_write_msg = "Something went wrong during writing to $GNU_OUTPATH. Aborted.\n";
#calculation of the confidence intervals of all value pairs per value type
foreach my $density ( sort {$a <=> $b} keys %mapNumNodes ) #presumption: all maps have the same keys
{
	my $numberNodes = calculateMean(@{$mapNumNodes{$density}});
	print OUT "$density$OUT_SPLIT_CHAR$numberNodes$OUT_SPLIT_CHAR" or die "$error_write_msg";
	
	estimateConfidenceIntervals("minEuclDis", $density, @{$mapEuclDistance{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";
	
	estimateConfidenceIntervals("minEuclDisUDG", $density, @{$mapEuclDistance_UDG_min{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("minHopDisUDG", $density, @{$mapHopDistance_UDG_min{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("minEuclDisGG", $density, @{$mapEuclDistance_GG_min{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("minHopDisGG", $density, @{$mapHopDistance_GG_min{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("minEuclDisPDT", $density, @{$mapEuclDistance_PDT_min{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("minHopDisPDT", $density, @{$mapHopDistance_PDT_min{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";
	
	estimateConfidenceIntervals("euclDisFaceRGG", $density, @{$mapEuclDistance_FaceR_GG{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("hopDisFaceRGG", $density, @{$mapHopDistance_FaceR_GG{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("euclDisFaceRPDT", $density, @{$mapEuclDistance_FaceR_PDT{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("hopDisFaceRPDT", $density, @{$mapHopDistance_FaceR_PDT{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("euclDisGFGGG", $density, @{$mapEuclDistance_GFG_GG{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("hopDisGFGGG", $density, @{$mapHopDistance_GFG_GG{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";
	
	estimateConfidenceIntervals("euclDisGFGPDT", $density, @{$mapEuclDistance_GFG_PDT{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	estimateConfidenceIntervals("hopDisGFGPDT", $density, @{$mapHopDistance_GFG_PDT{$density}});
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioEuclDisFaceR_minEuclDis_GG = twoArrayDiv(\@{$mapEuclDistance_FaceR_GG{$density}}, \@{$mapEuclDistance_GG_min{$density}});
	estimateConfidenceIntervals("euclDisFaceRGG/minEuclDisGG", $density, @ratioEuclDisFaceR_minEuclDis_GG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioHopDisFaceR_minHopDis_GG = twoArrayDiv(\@{$mapHopDistance_FaceR_GG{$density}}, \@{$mapHopDistance_GG_min{$density}});
	estimateConfidenceIntervals("hopDisFaceRGG/minHopDisGG", $density, @ratioHopDisFaceR_minHopDis_GG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";
	
	my @ratioEuclDisFaceR_minEuclDis_PDT = twoArrayDiv(\@{$mapEuclDistance_FaceR_PDT{$density}}, \@{$mapEuclDistance_PDT_min{$density}});
	estimateConfidenceIntervals("euclDisFaceRPDT/minEuclDisPDT", $density, @ratioEuclDisFaceR_minEuclDis_PDT);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioHopDisFaceR_minHopDis_PDT = twoArrayDiv(\@{$mapHopDistance_FaceR_PDT{$density}}, \@{$mapHopDistance_PDT_min{$density}});
	estimateConfidenceIntervals("hopDisFaceRPDT/minHopDisPDT", $density, @ratioHopDisFaceR_minHopDis_PDT);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioEuclDisGFG_minEuclDis_GG = twoArrayDiv(\@{$mapEuclDistance_GFG_GG{$density}}, \@{$mapEuclDistance_GG_min{$density}});
	estimateConfidenceIntervals("euclDisGFGGG/minEuclDisGG", $density, @ratioEuclDisGFG_minEuclDis_GG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioHopDisGFG_minHopDis_GG = twoArrayDiv(\@{$mapHopDistance_GFG_GG{$density}}, \@{$mapHopDistance_GG_min{$density}});
	estimateConfidenceIntervals("hopDisGFGGG/minHopDisGG", $density, @ratioHopDisGFG_minHopDis_GG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioEuclDisGFG_minEuclDis_PDT = twoArrayDiv(\@{$mapEuclDistance_GFG_PDT{$density}}, \@{$mapEuclDistance_PDT_min{$density}});
	estimateConfidenceIntervals("euclDisGFGPDT/minEuclDisPDT", $density, @ratioEuclDisGFG_minEuclDis_PDT);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioHopDisGFG_minHopDis_PDT = twoArrayDiv(\@{$mapHopDistance_GFG_PDT{$density}}, \@{$mapHopDistance_PDT_min{$density}});
	estimateConfidenceIntervals("hopDisGFGPDT/minHopDisPDT", $density, @ratioHopDisGFG_minHopDis_PDT);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioEuclDisFaceRGG_minEuclDis_UDG = twoArrayDiv(\@{$mapEuclDistance_FaceR_GG{$density}}, \@{$mapEuclDistance_UDG_min{$density}});
	estimateConfidenceIntervals("euclDisFaceRGG/minEuclDisUDG", $density, @ratioEuclDisFaceRGG_minEuclDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioHopDisFaceRGG_minHopDis_UDG = twoArrayDiv(\@{$mapHopDistance_FaceR_GG{$density}}, \@{$mapHopDistance_UDG_min{$density}});
	estimateConfidenceIntervals("hopDisFaceRGG/minHopDisUDG", $density, @ratioHopDisFaceRGG_minHopDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioEuclDisFaceRPDT_minEuclDis_UDG = twoArrayDiv(\@{$mapEuclDistance_FaceR_PDT{$density}}, \@{$mapEuclDistance_UDG_min{$density}});
	estimateConfidenceIntervals("euclDisFaceRPDT/minEuclDisUDG", $density, @ratioEuclDisFaceRPDT_minEuclDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioHopDisFaceRPDT_minHopDis_UDG = twoArrayDiv(\@{$mapHopDistance_FaceR_PDT{$density}}, \@{$mapHopDistance_UDG_min{$density}});
	estimateConfidenceIntervals("hopDisFaceRPDT/minHopDisUDG", $density, @ratioHopDisFaceRPDT_minHopDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioEuclDisGFGGG_minEuclDis_UDG = twoArrayDiv(\@{$mapEuclDistance_GFG_GG{$density}}, \@{$mapEuclDistance_UDG_min{$density}});
	estimateConfidenceIntervals("euclDisGFGGG/minEuclDisUDG", $density, @ratioEuclDisGFGGG_minEuclDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioHopDisGFGGG_minHopDis_UDG = twoArrayDiv(\@{$mapHopDistance_GFG_GG{$density}}, \@{$mapHopDistance_UDG_min{$density}});
	estimateConfidenceIntervals("hopDisGFGGG/minHopDisUDG", $density, @ratioHopDisGFGGG_minHopDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioEuclDisGFGPDT_minEuclDis_UDG = twoArrayDiv(\@{$mapEuclDistance_GFG_PDT{$density}}, \@{$mapEuclDistance_UDG_min{$density}});
	estimateConfidenceIntervals("euclDisGFGPDT/minEuclDisUDG", $density, @ratioEuclDisGFGPDT_minEuclDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioHopDisGFGPDT_minHopDis_UDG = twoArrayDiv(\@{$mapHopDistance_GFG_PDT{$density}}, \@{$mapHopDistance_UDG_min{$density}});
	estimateConfidenceIntervals("hopDisGFGPDT/minHopDisUDG", $density, @ratioHopDisGFGPDT_minHopDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioMinEuclDisGG_minEuclDis_UDG = twoArrayDiv(\@{$mapEuclDistance_GG_min{$density}}, \@{$mapEuclDistance_UDG_min{$density}});
	estimateConfidenceIntervals("minEuclDisGG/minEuclDisUDG", $density, @ratioMinEuclDisGG_minEuclDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioMinHopDisGG_minHopDis_UDG = twoArrayDiv(\@{$mapHopDistance_GG_min{$density}}, \@{$mapHopDistance_UDG_min{$density}});
	estimateConfidenceIntervals("minHopDisGG/minHopDisUDG", $density, @ratioMinHopDisGG_minHopDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioMinEuclDisPDT_minEuclDis_UDG = twoArrayDiv(\@{$mapEuclDistance_PDT_min{$density}}, \@{$mapEuclDistance_UDG_min{$density}});
	estimateConfidenceIntervals("minEuclDisPDT/minEuclDisUDG", $density, @ratioMinEuclDisPDT_minEuclDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	my @ratioMinHopDisPDT_minHopDis_UDG = twoArrayDiv(\@{$mapHopDistance_PDT_min{$density}}, \@{$mapHopDistance_UDG_min{$density}});
	estimateConfidenceIntervals("minHopDisPDT/minHopDisUDG", $density, @ratioMinHopDisPDT_minHopDis_UDG);
	print OUT "$OUT_SPLIT_CHAR" or die "$error_write_msg";

	print OUT "\n" or die "$error_write_msg";
}
close(OUT);
print "Finished writing to GNUPlot conform file \"$GNU_OUTPATH\" successfully!";
}